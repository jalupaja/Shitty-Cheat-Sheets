#+title: Haskell

| [[#Datatypes]]        |
| [[#Types]]            |
| [[#Pattern Matching]] |
| [[#where_bindings]]   |
| [[#let_bindings]]     |
| [[#Guards]]           |
| [[#Case_expressions]] |
| [[#Resources]]        |

* Datatypes
| Datatype | info               |
|----------+--------------------|
| Int      | Number             |
| Integer  | Int with no bounds |
| Float    | Floating Point     |
| Double   | Bigger Float       |
| Bool     | True or False      |
| Char     | Character          |

* Types
| Type     | Explanation             |
|----------+-------------------------|
| Ord      | Order-able              |
| Eq       | Equality testable       |
| Num      | any Number              |
| Integral | only whole numbers      |
| Floating | Flaot, Double           |
| Ordering | GT, LT, EQ              |
| Show     | String-able             |
| Read     | Can be read from String |
| Enum     | enumerate-able          |
| Bounded  | Have lower, upper bound |

* Pattern Matching
#+begin_src Haskell
scnd :: (a, b, c) -> a
scnd (_, x, _) = x
#+end_src
* where_bindings
`where` clause can be used to define local variables or functions at the end of a function.
Variables defined in the `where` clause are visible inside the function as well as across guards.
two different ways of writing where clauses:
#+begin_src Haskell
    where x = 1
        y = 2
        x = 3
#+end_src
#+begin_src Haskell
    where (x, y, z) = (1, 2, 3)
#+end_src
* let_bindings
`let` lets you bind local variables or functions to be used after `in`.
If there is no `in` part, it will be visible in the current scope.
#+begin_src Haskell
let x = 1
    y = 2
in x + y
#+end_src
#+begin_src Haskell
[let square x = x*x in (square 1, square 2, square 3)]
#+end_src
* Guards
like if else case
#+begin_src Haskell
nums :: (Num a) => a -> a -> a
nums x y
    | z < 1 = 0
    | z < 3 = ret_one
    | otherwise = 2
    where z = x+y
        ret_one = 1
#+end_src
if `otherwise` is missing, the function will fall through (if there are any more)
* Case_expressions
like switch case with pattern matching
#+begin_src Haskell
head' :: [a] -> a
head' xs = case xs of [] -> error "is empty"
            (x:_) -> x
#+end_src
* Resources
http://learnyouahaskell.com
